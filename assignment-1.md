# 📖 2024-2 오픈소스 소프트웨어 기초 (CLTR0794-001) TEAM 1

## 👩‍👩‍👧‍👦 팀원 정보

|전공|학번|이름|Github 계정|
|---|---|---|---|
|컴퓨터학부 심화컴퓨터전공|2020113486|김대건|[toothlessdev](https://github.com/toothlessdev)|
|컴퓨터학부 심화컴퓨터전공|2020115983|최기영|[gogumalatte](https://github.com/gogumalatte)|
|컴퓨터학부 글로벌SW융합전공|2021112334|김가희|[zzkim](https://github.com/zzkim)|
|컴퓨터학부 심화컴퓨터전공|2020116651|조현준|[HyunJunCho00](https://github.com/HyunJunCho00)|

## 📖 제목

### ✏️ 1. 개요

#### 1.1. Docker에 대한 소개

   **Docker**는 애플리케이션을 격리된 환경에서 실행할 수 있도록 도와주는 플랫폼으로, 컨테이너라는 경량화된 단위에서 애플리케이션을 실행하는 기술을 제공합니다. 컨테이너는 가상 머신과 달리 OS 커널을 공유하므로, 애플리케이션 실행 시 필요한 자원만 독립적으로 할당받아 효율적으로 동작합니다. 각 컨테이너는 애플리케이션 실행에 필요한 라이브러리, 설정 파일, 의존성 등을 포함하고 있어, 시스템 간 일관된 환경을 보장할 수 있습니다.

#### 1.2. Docker의 특징

Docker는 격리된 환경에서 애플리케이션을 실행할 수 있게 해주는 컨테이너 기반 플랫폼으로, 아래의 특징들이 있습니다.

1. **자원 효율성**:
  Docker 컨테이너는 호스트 시스템의 OS 커널을 공유하므로, 가상 머신보다 적은 자원을 사용하면서도 격리된 환경을 제공합니다. 이로 인해 더 많은 애플리케이션을 동시에 실행할 수 있어, 서버 자원의 활용도가 높아집니다.
2. **빠른 시작 시간**:
    Docker 컨테이너는 가상 머신보다 훨씬 빠르게 시작하고 중지할 수 있어, 개발 및 배포 속도가 빨라집니다. 이를 통해 필요한 순간에 필요한 애플리케이션을 신속히 실행할 수 있습니다.
3. **버전 관리와 롤백**:
    Docker 이미지는 버전 관리가 가능하여, 특정 버전으로 되돌아가거나, 이전 상태로 손쉽게 복구할 수 있습니다. 이를 통해 개발자는 안정적인 배포와 문제 해결을 할 수 있습니다.
4. **모듈화**:
    Docker를 사용하면 애플리케이션을 여러 컨테이너로 분할하여 관리할 수 있어, 애플리케이션의 각 부분을 독립적으로 개발하고 배포할 수 있습니다. 이는 마이크로서비스 아키텍처를 구현할 때 매우 유리합니다.
5. **확장성과 유연성**:
    Docker는 다양한 호스팅 환경에서 확장 가능하며, 컨테이너를 원하는 수만큼 추가하고 제거할 수 있습니다. 이를 통해 사용량에 따라 자원을 동적으로 조정할 수 있습니다.
6. **멀티스테이지 빌드 (Multistage Build)**
    Docker는 멀티스테이지 빌드를 통해 이미지를 효율적으로 만들고, 불필요한 파일을 포함하지 않도록 최적화할 수 있습니다. 이는 이미지 크기를 줄이고 배포 속도를 높이는 데 유리합니다.

#### 1.3. Docker의 장점
1. **컨테이너 이미지의 이식성**:
 개발자는 Docker 이미지를 사용해 특정 애플리케이션의 실행 환경을 손쉽게 재현할 수 있으며, 이 이미지는 다양한 운영 체제나 클라우드 플랫폼에서 동일하게 동작합니다. 또한, 컨테이너 이미지의 계층 구조로 인해 작은 변경 사항만 이미지에 추가하면 되므로, 이미지의 크기를 최소화하면서도 효율적인 배포가 가능합니다.

2. **Docker Hub**:
   Docker Hub는 Docker의 공식 이미지 저장소로, 다양한 오픈소스 애플리케이션 및 운영 환경에 최적화된 이미지를 제공하여 개발자가 원하는 환경을 쉽게 구성할 수 있도록 돕습니다. 이러한 이미지들은 버전 관리가 가능해 과거의 이미지로 복구하거나 다양한 버전 간에 전환이 용이합니다.

3. **개발 및 운영 환경의 일관성**
  Docker는 개발 환경과 실제 운영 환경의 차이를 최소화하여, "내 로컬에서는 잘 되는데..."와 같은 문제를 줄입니다. 이를 통해 개발자가 동일한 환경에서 테스트하고, 배포된 후에도 일관된 결과를 얻을 수 있습니다.

4. **자동화와 효율성**
  Docker는 Dockerfile을 통해 애플리케이션 이미지를 자동으로 빌드할 수 있는 방법을 제공합니다. Dockerfile을 사용하면 동일한 이미지를 반복적으로 빌드할 수 있으며, 이를 통해 CI/CD 파이프라인에서 자동화된 환경을 구성할 수 있습니다.

5. **CI/CD 파이프라인**:
 새로운 코드가 커밋되면, 컨테이너 기반 환경에서 자동으로 빌드, 테스트, 배포가 이루어지기 때문에, 개발과 운영 간의 통합을 원활하게 합니다. 개발팀은 동일한 컨테이너 이미지를 통해 서로 다른 환경에서도 동일한 결과를 기대할 수 있으며, 이를 통해 DevOps 문화를 촉진시킵니다.

6. **네트워킹 측면에서의 유연한 설정을 제공**:
 컨테이너 간의 네트워크는 가상화된 네트워크 인터페이스를 통해 독립적으로 구성되며, 각 컨테이너는 다른 컨테이너와의 통신을 쉽게 설정할 수 있습니다. 또한, 외부 네트워크와의 연결도 간편하게 관리할 수 있어 클라우드나 로컬 환경에서 확장성이 뛰어납니다.

7. **Kubernetes**:
 Docker는 여러 컨테이너를 효율적으로 관리할 수 있는 오케스트레이션 도구인 Kubernetes와 결합하여 대규모의 마이크로서비스 아키텍처를 손쉽게 구축할 수 있게 해줍니다. Kubernetes는 수많은 컨테이너를 자동으로 배포하고 관리하는 역할을 하며, 서비스의 가용성과 확장성을 보장합니다. Docker Swarm은 Docker의 자체 오케스트레이션 도구로, 클러스터 기반의 애플리케이션 관리를 지원합니다.

Docker는 경량화된 특성과 손쉬운 관리, 배포, 이식성 덕분에 현대 소프트웨어 개발 및 배포 환경에서 핵심적인 역할을 수행하고 있습니다.

### ✏️ 2. 라이선스
   
#### 2.1 Docker Engine Community Edition (Docker CE): 
   Docker의 오픈소스 버전으로, 개인과 중소기업이 무료로 사용할 수 있습니다. Docker CE는 오픈소스 라이선스인 Apache 2.0 라이선스를 따릅니다. 이는 누구나 자유롭게 소프트웨어를 사용, 수정, 배포할 수 있음을 의미합니다.

#### 2.2 Docker Engine Enterprise Edition (Docker EE):
   Docker의 상용 버전으로, 기업을 대상으로 한 추가 기능과 지원을 제공합니다. 가격은 기업의 규모 및 요구 사항에 따라 달라질 수 있으며, 기본적으로 연간 구독 요금제로 운영됩니다. Docker EE의 비용은 사용자나 CPU 수에 따라 다양하지만, 대략 연간 수백에서 수천 달러에 이르는 경우가 많습니다.

#### 2.3 Docker Desktop:
Docker Desktop은 Windows 및 macOS에서 사용할 수 있는 Docker의 GUI 기반 애플리케이션입니다. Docker Desktop은 Docker CE와 함께 제공되며, 개인과 소규모 팀에게는 무료이지만, 상업적 사용의 경우 유료 구독 요금제가 적용될 수 있습니다. Docker Personal 플랜은 무료로 제공되지만, 100명 이상의 직원을 보유한 기업 또는 상업적 목적으로는 유료 구독 플랜인 Docker Pro, Team, Business가 필요할 수 있습니다.

#### 2.4 Docker Subscription Plans:
Docker는 개인 및 기업 사용자들을 위해 다양한 구독 플랜을 제공합니다.

Docker Personal: 무료 플랜으로, 개인 개발자와 비상업적 용도에 적합합니다.
Docker Pro: 개인 개발자 및 프리랜서에게 적합하며, 월간 또는 연간 구독으로 제공됩니다.
Docker Team: 협업 기능을 제공하며, 소규모 팀을 위한 플랜입니다.
Docker Business: 기업용으로, 관리 도구 및 강화된 보안 기능을 제공합니다.
이 구독 플랜들은 Docker Hub 이미지 저장소의 용량, 팀 협업 기능, 보안 기능, 자동화된 빌드 등의 추가 기능과 지원에 따라 다릅니다.

#### 2.5 Docker 엔터프라이즈 지원:
Docker EE는 기업을 위한 공식 지원 서비스를 제공하며, 이는 라이선스 비용에 포함되어 있습니다. Docker는 SLA(Service Level Agreement)에 따라 다양한 수준의 기술 지원을 제공하며, 보안 패치 및 긴급 문제 해결에 대한 전담 지원을 포함합니다.


### ✏️ 3. 주요 기능

#### 3.1. 도커 레지스트리(Docker Registry)
도커 레지스트리는 도커 이미지를 중앙에서 저장, 공유, 그리고 관리하는 핵심 시스템입니다. 도커 이미지란 애플리케이션 실행에 필요한 파일 시스템, 라이브러리, 설정 등이 포함된 패키지로, 이러한 이미지를 중앙 레지스트리에 저장함으로써, 팀 내에서 또는 다양한 배포 환경에서 이미지를 효율적으로 관리하고 사용할 수 있게 됩니다.

레지스트리는 퍼블릭과 프라이빗으로 나뉘며, 퍼블릭 레지스트리의 대표적인 예로 `도커 허브(Docker Hub)`가 있습니다. 도커 허브는 전 세계 개발자들이 이미지를 자유롭게 공유하거나, 공식 이미지를 제공받을 수 있는 플랫폼입니다. 반면, 기업 내부에서 사용하는 `프라이빗 레지스트리(Private Registry)`는 보안 요구 사항에 맞게 설계되어 특정 권한이 있는 사용자만 접근할 수 있도록 설정되며, 민감한 데이터나 독점 소프트웨어 이미지를 안전하게 관리할 수 있습니다.

도커 레지스트리는 사용자나 팀이 애플리케이션을 컨테이너화하여 일관된 환경에서 실행하고, 이를 다양한 배포 시스템으로 확장할 수 있도록 해주는 강력한 도구입니다. 이미지의 버전 관리, 태깅, 자동화된 빌드 및 배포와 같은 기능들을 통해, 개발에서 운영까지 일관된 워크플로우를 지원합니다.

##### 도커 레지스트리의 핵심 구성 요소

1. **도커 이미지(Docker Image)**:  
   도커 이미지는 컨테이너의 기반이 되는 불변의 파일 시스템입니다. 애플리케이션과 그 애플리케이션을 실행하는 데 필요한 라이브러리, 설정 파일, 시스템 도구, 런타임 등이 이 이미지에 포함됩니다. 도커 이미지는 여러 레이어로 구성되며, 각 레이어는 불변으로 저장됩니다. 이미지가 업데이트될 때는 변경된 레이어만 추가되고, 이전 레이어는 재사용됩니다. 이는 이미지 크기를 줄이고 빌드 및 배포 속도를 개선하는 데 큰 도움이 됩니다. 또한 이미지는 태그(tag)를 통해 버전별로 관리되며, `latest`는 최신 버전을, 특정 버전 번호는 해당 이미지를 가리킵니다.

2. **도커 허브(Docker Hub)**:  
   도커 허브는 도커 이미지의 중앙 저장소이자 배포 플랫폼입니다. 사용자는 도커 허브에서 공식 이미지를 다운로드하거나 자신의 이미지를 공유할 수 있습니다. 도커 허브는 오픈 소스 프로젝트나 기업에서 널리 사용되며, 다양한 이미지들이 무료로 제공됩니다. 공식 이미지 외에도 사용자들이 만든 커스텀 이미지를 제공하는 퍼블릭 레포지토리가 있으며, 개인적 또는 팀 내에서만 접근 가능한 프라이빗 레포지토리도 사용할 수 있습니다. 도커 허브는 CI/CD(지속적 통합/지속적 배포) 파이프라인에서 이미지를 자동으로 푸시하거나 풀하는 데 자주 사용됩니다.
   
4. **프라이빗 레지스트리(Private Registry)**:  
   프라이빗 레지스트리는 기업이나 조직이 도커 이미지를 외부에 노출시키지 않고 안전하게 관리할 수 있도록 하는 도커 레지스트리의 개인 버전입니다. 도커는 사용자가 직접 프라이빗 레지스트리를 설정하고 운영할 수 있는 기능을 제공합니다. 이 레지스트리는 내부 네트워크에서만 접근할 수 있도록 설정하거나, 특정 권한이 있는 사용자만 접근 가능하도록 할 수 있습니다. TLS 인증서 등을 통해 보안이 강화된 통신을 제공하며, 필요에 따라 이미지를 암호화하거나 서명할 수 있습니다. 기업들은 보안 정책에 따라 외부 레지스트리를 사용하지 않고 프라이빗 레지스트리를 통해 이미지의 배포와 관리를 수행하는 경우가 많습니다.

##### 도커 레지스트리의 주요 기능

1. **이미지 저장 및 관리**:  
   도커 레지스트리는 사용자가 생성한 컨테이너 이미지를 중앙 집중식으로 저장하고 관리하는 기능을 제공합니다. 각 이미지는 독립적인 실행 환경을 제공하며, 다양한 버전으로 관리할 수 있습니다. 도커 이미지에는 애플리케이션 실행에 필요한 모든 파일, 라이브러리, 환경 설정이 포함되어 있어 배포 시 의존성 문제를 최소화합니다. 사용자는 이미지를 버전별로 태그를 부여하여 관리할 수 있으며, 이를 통해 특정 버전의 이미지를 정확하게 추적하고 사용할 수 있습니다. 예를 들어, `myapp:1.0`, `myapp:2.0`같은 태그를 붙여 각기 다른 버전의 애플리케이션을 배포할 수 있습니다. 태그를 통해 애플리케이션의 변경 사항을 관리하고, 언제든지 이전 버전으로 롤백하는 것이 가능합니다.

2. **이미지 배포 및 공유**:  
   도커 레지스트리는 이미지 배포와 공유를 간편하게 만들어 줍니다. 도커 허브와 같은 퍼블릭 레지스트리를 통해 누구나 이미지를 다운로드할 수 있는 형태로 공개할 수 있습니다. 개발자 커뮤니티나 오픈 소스 프로젝트에서 이미지 공유 시에 이 방식이 주로 사용됩니다. 반면, 민감한 데이터나 보안 요구 사항이 있는 환경에서는 프라이빗 레지스트리를 사용해 이미지 접근을 제한할 수 있습니다. 프라이빗 레지스트리에서는 사용자 인증 및 권한 관리가 필수적으로 이루어지며, 이를 통해 팀 내의 특정 구성원이나 시스템에서만 이미지에 접근할 수 있도록 설정할 수 있습니다.
   
3. **도커 CLI를 통한 손쉬운 푸시/풀(Push/Pull)**:
   도커 CLI(Command Line Interface)는 도커 레지스트리와 상호작용하는 가장 기본적인 도구입니다. 명령줄에서 `docker push` 명령어를 사용해 로컬 이미지를 지정된 레지스트리에 업로드할 수 있으며, `docker pull` 명령어를 사용해 레지스트리에서 이미지를 다운로드할 수 있습니다. 이러한 작업은 CI/CD 파이프라인에서 자동화될 수 있으며, 개발 환경에서 운영 환경으로의 이미지 배포를 신속하고 효율적으로 수행할 수 있습니다. 명령어 예시는 다음과 같습니다:
   - `docker push <레포지토리명>:<태그>` 명령을 사용하여 이미지를 레지스트리에 업로드
   - `docker pull <레포지토리명>:<태그>` 명령을 사용하여 이미지를 로컬로 다운로드
이를 통해 개발자나 팀은 쉽고 빠르게 이미지를 공유하고 배포할 수 있으며, 여러 버전의 이미지를 관리할 수 있습니다.

4. **이미지 버전 관리 및 태깅(Tagging)**:  
   도커는 이미지 버전 관리와 태깅 시스템을 통해 여러 버전의 이미지를 효율적으로 관리할 수 있습니다. 각각의 이미지는 하나 이상의 태그를 가질 수 있으며, 이를 통해 특정 애플리케이션 버전 또는 환경에 맞는 이미지를 구분합니다. `latest` 태그는 일반적으로 최신 버전의 이미지를 가리키며, 이를 통해 자동으로 최신 버전의 이미지를 사용할 수 있습니다. 반면, 명시적인 버전 번호(`v1.0`, `v2.1` 등)를 통해 안정성이 보장된 버전을 사용할 수 있습니다. 태깅은 이미지 관리의 핵심으로, 애플리케이션 배포 시 특정 버전을 선택하여 재현성 있는 환경을 제공하며, 과거 버전으로 쉽게 롤백할 수 있도록 지원합니다.
   
5. **레지스트리 관리 및 보안 설정**:  
   프라이빗 레지스트리를 운영하는 경우, 관리자는 보안을 강화하기 위해 다양한 설정을 할 수 있습니다. 사용자 인증, 권한 관리, 그리고 TLS 인증서를 사용하여 레지스트리의 보안을 유지하고, HTTPS를 통해 안전한 전송을 보장할 수 있습니다. 도커는 또한 `Docker Content Trust` 기능을 통해 이미지 서명을 지원하며, 이를 통해 무결성을 확인하고 서명되지 않은 이미지의 배포를 방지할 수 있습니다. 보안 취약점을 사전에 식별할 수 있는 자동화된 보안 스캔 기능을 통해, 기업은 도커 이미지를 배포하기 전에 잠재적인 보안 위협을 탐지하고 해결할 수 있습니다. 이러한 보안 기능을 통해 도커 레지스트리는 민감한 데이터를 안전하게 보호하고, 외부로부터의 공격을 방지할 수 있는 높은 수준의 보안 환경을 제공합니다.

#### 도커 레지스트리의 주요 특징

1. **이미지 캐시(Cache) 및 레이어 재사용**  
   도커는 이미지 레이어를 캐시하고 재사용하여, 동일한 레이어를 가진 여러 이미지들이 효율적으로 저장되고 관리될 수 있습니다. 레이어가 변경되지 않았다면, 해당 레이어를 다시 다운로드하거나 재생성할 필요 없이 바로 재사용할 수 있어 빌드와 배포 시간을 단축합니다. 특히 CI/CD 파이프라인에서 이를 적극 활용할 수 있습니다.

2. **이미지 서명(Docker Content Trust 및 Notary)**  
   도커는 이미지의 무결성과 신뢰성을 보장하기 위해 **Docker Content Trust(DCT)** 기능을 제공합니다. 이 기능은 이미지가 변경되지 않았고 신뢰할 수 있는 출처에서 왔는지를 보장합니다. 이를 통해 서명되지 않은 이미지를 사용하지 않도록 설정하여, 무결성이 깨진 이미지로부터 시스템을 보호할 수 있습니다. 또한, **Notary**와의 통합을 통해 더 강력한 서명 및 인증 시스템을 구축할 수 있습니다.

3. **이미지 압축과 전송 최적화**  
   도커 레지스트리는 이미지를 전송할 때 압축을 통해 네트워크 대역폭을 절약하고 전송 속도를 최적화합니다. 이는 특히 대규모의 이미지를 배포할 때 큰 이점을 제공합니다. 또한, 레이어 단위로 이미지가 전송되므로, 필요한 레이어만을 다운로드할 수 있어 기존의 전송 방식보다 효율적입니다.

4. **자동화된 이미지 클린업 및 관리**  
   도커 레지스트리를 장시간 운영할 경우, 불필요하게 저장된 오래된 이미지들이 시스템 리소스를 낭비할 수 있습니다. 이를 방지하기 위해 자동화된 이미지 클린업 기능을 구현하여, 사용되지 않거나 오래된 이미지를 자동으로 제거함으로써 저장 공간을 절약할 수 있습니다. 또한, 이를 통해 레지스트리의 성능을 유지하고 관리 비용을 절감할 수 있습니다.

5. **레지스트리 확장 및 로드 밸런싱**  
   대규모 시스템에서는 단일 레지스트리 서버로 모든 트래픽을 처리하기 어려울 수 있습니다. 도커 레지스트리는 확장 가능한 구조로 설계되어 있어, 여러 레지스트리 인스턴스를 클러스터로 구성하거나 로드 밸런싱을 적용하여 성능을 향상시킬 수 있습니다. 이를 통해 다수의 사용자가 동시에 이미지를 업로드하거나 다운로드할 때도 안정적인 서비스 제공이 가능합니다.

6. **레지스트리 레플리케이션(Registry Replication)**  
   도커 레지스트리는 여러 지리적 위치에 걸쳐 레지스트리를 복제할 수 있는 기능을 지원합니다. 이를 통해 다양한 글로벌 배포 환경에서 동일한 이미지를 여러 곳에서 빠르게 액세스할 수 있습니다. 이 기능은 특히 다국적 기업이나 전 세계에 걸쳐 서비스가 제공되는 경우 유용합니다.

7. **이미지 취약점 스캐닝(Vulnerability Scanning)**  
   도커 허브와 일부 프라이빗 레지스트리는 업로드된 이미지에 대해 보안 취약점 스캔을 제공합니다. 이는 컨테이너 내에서 사용되는 소프트웨어 패키지의 보안 결함을 식별하고, 이를 해결할 수 있도록 도와줍니다. 이 기능은 특히 DevSecOps 환경에서 중요하며, CI/CD 파이프라인에서 자동화된 보안 검사를 수행할 수 있는 중요한 요소입니다.

##### 도커 레지스트리와 레포지토리의 구조

- **레지스트리(Registry)**:
  도커 레지스트리는 도커 이미지를 저장하고 관리하는 중앙 시스템입니다. 각 레지스트리는 다수의 레포지토리(Repository)를 포함할 수 있으며, 이를 통해 애플리케이션 이미지 및 그 버전들을 체계적으로 관리할 수 있습니다. 도커 허브(Docker Hub)는 가장 널리 사용되는 퍼블릭 레지스트리로, 개발자들이 전 세계적으로 이미지를 공유하고 다운로드할 수 있는 플랫폼입니다. 기업의 경우 보안이 중요한 환경에서 프라이빗 레지스트리를 운영하여 외부 접근을 제한하고 내부적으로 이미지를 관리할 수 있습니다.
- **레포지토리(Repository)**:
  레포지토리는 특정 애플리케이션이나 서비스에 대한 여러 버전의 이미지가 저장된 집합체입니다. 예를 들어, nginx라는 레포지토리에는 Nginx 웹 서버의 다양한 버전이 포함됩니다. 레포지토리는 태그(tag)를 통해 버전별로 이미지를 구분합니다. 각 태그는 특정 버전의 이미지를 가리키며, 이를 통해 다양한 배포 환경에서 일관된 애플리케이션 실행을 보장합니다. 또한, 하나의 레포지토리 안에 다양한 아키텍처나 환경에 맞춘 여러 버전의 이미지가 저장될 수 있습니다.
- **이미지(Image)**:
  도커 이미지는 애플리케이션을 실행하기 위한 모든 필요한 파일, 설정, 라이브러리, 그리고 런타임 환경을 포함하는 패키지입니다. 이미지는 불변의 레이어로 구성되어 있으며, 각 레이어는 독립적으로 관리됩니다. 도커 이미지는 기본적으로 읽기 전용(read-only)으로 저장되며, 동일한 애플리케이션의 다양한 버전이나 수정 사항에 따라 여러 이미지가 레포지토리에 저장됩니다. 이미지는 Dockerfile을 기반으로 빌드되며, 특정 환경에 맞게 최적화된 애플리케이션 실행 환경을 제공할 수 있습니다. 이를 통해 개발 환경과 운영 환경 간의 일관성을 유지할 수 있습니다.
##### 도커 레지스트리와 CI/CD

도커 레지스트리는 CI/CD 파이프라인의 중요한 요소로도 사용됩니다. 개발자가 코드를 수정하고, 자동으로 이미지를 빌드한 후, 이를 도커 레지스트리에 업로드하면, 배포 서버가 이를 자동으로 받아 실행합니다. 이 방식은 개발과 배포의 효율성을 극대화할 수 있습니다.

##### 도커 레지스트리 관련 명령어 예시

- **이미지 푸시(Push)**
   ```bash
   docker push <레지스트리>/<레포지토리>:<태그>
   ```
   도커 이미지를 레지스트리에 업로드합니다.
  
- **이미지 풀(Pull)**
   ```bash
   docker pull <레지스트리>/<레포지토리>:<태그>
   ```
   레지스트리에서 이미지를 내려받습니다.

- **프라이빗 레지스트리 실행**  
   로컬에서 프라이빗 레지스트리를 실행할 수 있습니다:
   ```bash
   docker run -d -p 5000:5000 --name registry registry:2
   ```

도커 레지스트리는 도커 생태계의 중요한 구성 요소로, 이미지를 쉽게 저장하고 관리하며 배포할 수 있는 핵심 도구입니다.

### 3.2. 도커의 이미지 레이어링(Docker Image Layering)

**도커 이미지 레이어링**은 도커 이미지가 여러 레이어(layer)로 구성되어 효율적인 저장 및 배포가 가능하게 만드는 도커의 중요한 기술입니다. 각 레이어는 불변이며, 새로운 변경 사항이 발생할 때마다 기존 레이어를 수정하는 대신 새로운 레이어가 추가됩니다. 이로 인해 도커 이미지는 효율적으로 관리되고, 불필요한 중복 저장을 방지하면서 개발 및 배포 효율성을 극대화할 수 있습니다. 도커 이미지 레이어링은 애플리케이션을 반복적으로 배포하거나 업데이트할 때 특히 유용하며, 이를 통해 이미지가 빠르게 빌드되고 전송됩니다.

#### 도커 이미지 레이어링의 핵심 개념

1. **불변성 (Immutability)**:
   도커 이미지의 각 레이어는 불변성을 가지고 있습니다. 한 번 생성된 레이어는 절대 변경되지 않으며, 만약 이미지에 수정 사항이 생기면 기존 레이어는 그대로 유지되고 새로운 레이어가 추가됩니다. 이를 통해 각 이미지의 일관성을 유지할 수 있고, 과거의 레이어가 손상되거나 변경되는 것을 방지할 수 있습니다. 이러한 불변성 덕분에 도커 이미지는 보다 안정적이고 예측 가능하게 관리됩니다. 또한, 변경 사항만을 새로운 레이어로 추가해 저장 공간을 절약하는 효과도 있습니다.

2. **캐시 활용 (Layer Caching)**:
   도커는 레이어 캐싱을 통해 이미 존재하는 레이어를 재사용합니다. 새로운 이미지를 빌드할 때, 기존 이미지와 동일한 레이어가 있다면 이를 캐시에서 가져와 재사용하며, 변경된 부분만 새롭게 빌드됩니다. 이를 통해 빌드 시간을 크게 단축시킬 수 있으며, 중복된 빌드 작업을 최소화할 수 있습니다. 특히, CI/CD 파이프라인에서 빈번한 이미지 빌드가 요구될 때, 캐시를 활용하여 빠른 배포가 가능해집니다. 예를 들어, 애플리케이션 업데이트 시 변경된 소스 코드 레이어만 빌드하고, 나머지 종속성 레이어는 캐시를 통해 재사용함으로써 전체 빌드 시간을 줄일 수 있습니다.

3. **층별 저장 (Layered Storage)**:
   도커 이미지 레이어링은 층별 저장 방식을 통해 이미지를 구조적으로 저장하고 관리합니다. 이미지의 각 레이어는 파일 시스템의 스냅샷과 유사하게 동작하며, 특정 작업의 결과가 해당 레이어로 기록됩니다. 예를 들어, 기본 운영체제 레이어 위에 애플리케이션 종속성, 라이브러리, 소스 코드 등의 각기 다른 레이어가 추가됩니다. 이러한 레이어 구조 덕분에 동일한 운영체제나 라이브러리 레이어를 여러 애플리케이션에서 재사용할 수 있습니다. 이를 통해 저장 공간을 절약할 수 있을 뿐만 아니라, 레이어별로 관리가 가능하여 효율적인 이미지 관리를 할 수 있습니다.

4. **최소화된 데이터 전송 (Efficient Data Transfer)**:
   도커의 이미지 레이어링 덕분에 전체 이미지를 다시 전송하지 않고, 변경된 레이어만 전송할 수 있습니다. 이는 네트워크 대역폭을 절약할 수 있고, 이미지 배포 속도를 높이는 데 중요한 역할을 합니다. 예를 들어, 도커 이미지를 배포할 때 운영체제와 같은 기본 레이어는 이미 대상 서버에 존재할 경우, 새로 빌드된 애플리케이션 레이어만 전송하면 되므로, 배포가 더 빠르고 효율적으로 이루어집니다. 이는 특히 대규모 환경에서 중요한 역할을 하며, 이미지의 빠른 업데이트와 배포를 가능하게 합니다.

#### 도커 이미지 레이어링의 주요 기능

- **이미지 빌드 최적화**:
  도커 파일의 각 명령(RUN, COPY, ADD 등)은 새로운 레이어를 생성합니다. 따라서 도커 파일을 최적화하면 불필요한 레이어 생성을 방지하고, 빌드 속도를 향상시킬 수 있습니다. 예를 들어, 도커 파일의 명령어 순서를 최적화하여 캐시를 최대한 활용하고, 변경이 적은 부분을 상단에 배치하는 것이 빌드 시간을 줄이는 데 도움이 됩니다. 이로 인해 빌드 작업의 효율성을 극대화할 수 있으며, 캐시를 재사용할 수 있는 부분을 쉽게 식별할 수 있습니다.

- **레이어의 공유 및 재사용**:
  여러 도커 이미지가 동일한 레이어를 공유함으로써 저장 공간과 네트워크 자원을 절약할 수 있습니다. 예를 들어, 동일한 베이스 이미지를 사용하는 여러 애플리케이션이 있을 경우, 운영체제 레이어는 여러 이미지 간에 공유되어 중복된 저장 공간을 최소화할 수 있습니다. 이를 통해 도커 이미지의 전송 속도와 저장 효율성을 높일 수 있습니다.

- **빌드 변경 사항 최소화**:
  이미지의 상위 레이어만 변경된 경우, 하위 레이어는 다시 빌드되지 않고 캐시에서 재사용됩니다. 이는 빌드 시간을 줄일 뿐만 아니라 CI/CD 파이프라인에서의 효율성을 극대화합니다. 특히 빈번한 소스 코드 업데이트가 발생하는 환경에서는 소스 코드 레이어만 업데이트하고, 나머지 종속성 레이어는 그대로 유지하므로 빠르고 효율적인 빌드가 가능합니다.

#### 도커 이미지 레이어링의 실제 활용
- **CI/CD 파이프라인에서의 사용**:
  도커 이미지 레이어링은 CI/CD 파이프라인에서 매우 중요한 역할을 합니다. 애플리케이션을 자주 빌드하고 배포하는 환경에서, 각 빌드가 불필요한 작업을 반복하지 않도록 캐시된 레이어를 재사용하여 전체 빌드 속도를 극대화할 수 있습니다. 이로 인해 개발자들은 코드 변경 시, 빠르게 피드백을 받고 애플리케이션을 안정적으로 배포할 수 있습니다.

- **다양한 환경에서의 이미지 관리**:
  도커 이미지는 다양한 환경에서 사용될 수 있으며, 이미지 레이어링을 통해 운영체제나 종속성 레이어를 공유하여 일관된 배포를 제공합니다. 예를 들어, 동일한 운영체제 이미지를 사용하여 서로 다른 애플리케이션을 배포할 경우, 기본 레이어를 공유하면서 각 애플리케이션만 독립적으로 관리할 수 있습니다.

#### 도커 이미지 레이어링 관련 명령어 예시

1. **이미지 빌드**:
   `docker build -t <이미지명> .` 명령을 사용하여 도커 파일을 기반으로 이미지를 빌드합니다. 도커 파일의 각 명령은 새로운 레이어를 생성하며, 변경된 레이어만 새롭게 빌드됩니다.

2. **이미지 확인**:
   `docker history <이미지ID>` 명령을 사용하여 이미지가 몇 개의 레이어로 이루어져 있는지, 각 레이어가 어떤 명령어로 생성되었는지 확인할 수 있습니다.

3. **이미지 레이어 보기**:
   `docker inspect <이미지ID>` 명령을 통해 이미지의 상세 정보를 확인하고, 각 레이어가 어떤 파일이나 명령을 포함하고 있는지 살펴볼 수 있습니다.

도커 이미지 레이어링은 이미지의 효율적인 저장 및 전송을 가능하게 하며, 이를 통해 개발 및 배포 과정에서 높은 성능을 제공합니다. 불변성, 캐시 활용, 층별 저장 등의 특성은 빌드 시간 단축, 저장 공간 절약, 그리고 네트워크 전송 최적화에 기여합니다. 도커 이미지 레이어링은 특히 CI/CD 파이프라인과 같이 반복적인 빌드와 배포가 요구되는 환경에서 필수적인 기능이며, 이를 통해 도커는 효율적이고 신뢰성 있는 컨테이너 환경을 제공합니다.

### 3.4. 도커의 다중 플랫폼 지원(Multi-platform Support)
도커의 다중 플랫폼 지원 기능은 여러 운영 체제와 아키텍처에서 컨테이너를 빌드하고 실행할 수 있게 해줍니다. 이를 통해 개발자는 다양한 환경에서 애플리케이션을 쉽게 배포할 수 있습니다. 다음은 다중 플랫폼 지원의 주요 기능 및 개념입니다.

#### 주요 기능

1. **다중 아키텍처 빌드(Multi-architecture Builds)**:
   도커는 다양한 CPU 아키텍처(x86, ARM, ARM64 등)에서 실행될 수 있는 이미지를 생성할 수 있습니다. 이는 개발자가 여러 플랫폼에서 애플리케이션을 테스트하고 배포할 수 있도록 도와줍니다. 예를 들어, docker buildx 명령어를 사용하여 여러 아키텍처에 대한 이미지를 동시에 빌드할 수 있습니다.

2. **Buildx 빌드도구**:
   buildx는 도커의 확장된 빌드 도구로, 여러 플랫폼에 대한 이미지를 생성할 수 있는 기능을 제공합니다. 사용자는 --platform 플래그를 통해 특정 아키텍처 및 운영 체제를 지정하여 이미지를 빌드할 수 있습니다.

```bash
docker buildx build --platform linux/amd64,linux/arm64 -t myimage:latest .
```
3. **다중 플랫폼 이미지(Multi-platform Images)**:
   다중 플랫폼 이미지는 여러 아키텍처의 다양한 버전을 포함하는 하나의 이미지입니다. 이러한 이미지를 사용하면 도커는 실행 중인 플랫폼에 맞는 올바른 버전을 자동으로 선택합니다. 이 기능은 manifest를 통해 구현되며, 도커는 이미지의 메타데이터를 관리하여 다양한 아키텍처의 이미지를 하나의 레지스트리에 푸시하고 풀 수 있습니다.

4. **플랫폼 감지(Platform Detection)**:
   도커는 컨테이너를 실행할 때 자동으로 현재 플랫폼을 감지하여 해당 플랫폼에 맞는 이미지를 선택합니다. 이로 인해 개발자는 특정 플랫폼에 맞춰 이미지를 수동으로 선택할 필요가 없습니다.

5. **Docker Desktop의 통합**:
   Docker Desktop에서는 다중 플랫폼 빌드를 보다 쉽게 사용할 수 있도록 GUI와 CLI 도구가 통합되어 있습니다. 사용자는 몇 번의 클릭으로 다양한 플랫폼 이미지를 빌드할 수 있습니다.

6. **Cross-architecture 컨테이너 실행**: 
   도커는 호스트 플랫폼과 다른 아키텍처의 컨테이너를 실행할 수 있도록 지원합니다. 예를 들어, ARM 아키텍처의 이미지를 x86 아키텍처에서 실행할 수 있습니다. 이 기능은 *QEMU*와 같은 에뮬레이터를 활용하여 가능합니다.
   
   - **QEMU(Quick Emulator) 개념**:
     다양한 CPU 아키텍처를 에뮬레이션하는 오픈 소스 소프트웨어로, 도커의 Cross-architecture 컨테이너 실행에서 중요한 역할을 합니다. 주요 기능은 다음과 같습니다:

   1. **다양한 아키텍처 지원**: QEMU는 x86, ARM, PowerPC 등 다양한 아키텍처에서 소프트웨어를 실행할 수 있도록 CPU 명령어를 변환합니다.

   2. **에뮬레이션 모드**:

   3. **전체 시스템 에뮬레이션**:
   QEMU는 전체 가상 컴퓨터를 에뮬레이션하여 서로 다른 아키텍처에서 운영 체제를 실행할 수 있습니다.

   4. **사용자 모드 에뮬레이션**: 특정 애플리케이션이 다른 아키텍처에서 실행될 수 있도록 지원합니다.

   5. **도커와의 통합**: 도커는 QEMU와 통합되어 ARM 등의 이미지를 x86 호스트에서 실행할 수 있습니다. 예를 들어, --platform linux/arm64 플래그를 사용하여 ARM 이미지를 실행할 수 있습니다.
   
   6. **개발 및 테스트**:
   QEMU는 물리적 장비 없이 다양한 아키텍처에서 애플리케이션을 개발하고 테스트하는 데 유용합니다.
   
   7. **KVM과의 조합**: QEMU는 KVM과 함께 사용될 때 성능을 개선하여 네이티브 성능에 가까운 가상화가 가능합니다.
   
   이러한 기능 덕분에 QEMU는 도커의 다중 플랫폼 지원을 가능하게 하여, 다양한 환경에서 애플리케이션을 실행하고 테스트할 수 있게 해줍니다.

#### 주요 특징

1. **Docker Desktop의 통합**:
Docker Desktop에서는 다중 플랫폼 빌드를 보다 쉽게 사용할 수 있도록 GUI와 CLI 도구가 통합되어 있습니다. 사용자는 몇 번의 클릭으로 다양한 플랫폼 이미지를 빌드할 수 있습니다.

2. **Docker Hub의 지원**:
   Docker Hub는 다중 플랫폼 이미지를 지원하며, 사용자가 한 레포지토리에 여러 아키텍처의 이미지를 저장하고 관리할 수 있도록 돕습니다.
   - **Docker Hub의 개념**:
       Docker 이미지를 저장, 관리, 배포할 수 있는 클라우드 기반 레지스트리 서비스입니다. 소프트웨어 개발자와 팀이 컨테이너 이미지를 공유하고 관리하는 데 널리 사용되며, 이미지 배포 자동화, 보안 관리 등의 기능을 제공합니다. 주요 특징은 다음과 같습니다:

      1. **컨테이너 이미지 저장 및 공유**: Docker Hub는 컨테이너 이미지를 저장하는 중앙 레포지토리 역할을 합니다. 개발자들은 이미지를 Docker Hub에 저장한 후 다른 사람들과 공유하거나 배포할 수 있습니다. 이를 통해 소프트웨어 개발 및 배포가 간소화됩니다.

      2. **다중 플랫폼 지원**: Docker Hub는 다중 아키텍처 이미지를 지원합니다. 즉, x86, ARM 등의 다양한 CPU 아키텍처를 위한 이미지를 하나의 레포지토리에 저장할 수 있습니다. 이 기능은 다양한 환경에서 동일한 애플리케이션을 실행할 수 있도록 돕습니다.

      3. **퍼블릭 및 프라이빗 레포지토리**: Docker Hub는 퍼블릭 레포지토리(누구나 접근 가능)와 프라이빗 레포지토리(사용자만 접근 가능)를 제공합니다. 퍼블릭 레포지토리는 오픈 소스 프로젝트나 일반 사용자들에게 유용하며, 프라이빗 레포지토리는 기업이나 팀 내에서 보안이 필요한 이미지를 저장할 때 사용됩니다.

      4. **자동화된 빌드**: Docker Hub는 GitHub 또는 Bitbucket과 통합하여 소스 코드가 업데이트될 때마다 자동으로 Docker 이미지를 빌드하고 레포지토리에 푸시하는 기능을 제공합니다. 이를 통해 배포 프로세스가 더욱 효율적으로 자동화됩니다.

      5. **이미지 관리 및 보안**: Docker Hub는 이미지 스캔 기능을 제공하여 이미지 내 취약점을 자동으로 감지하고, 이러한 취약점을 해결할 수 있는 방법을 제공합니다. 이를 통해 보안 강화를 돕고, 안정적인 이미지를 배포할 수 있도록 지원합니다.

      6. **웹 인터페이스 및 API**: Docker Hub는 사용자가 웹 인터페이스를 통해 쉽게 이미지를 관리할 수 있도록 직관적인 UI를 제공합니다. 또한 API를 통해 프로그램적으로 Docker Hub와 상호작용할 수 있습니다.

      이러한 기능을 통해 Docker Hub는 다양한 플랫폼과 아키텍처에 걸쳐 이미지를 손쉽게 관리하고 배포할 수 있는 중요한 도구로 자리잡고 있습니다.
3. **개발 및 CI/CD 환경 지원**:
다중 플랫폼 지원은 CI/CD 파이프라인에서 다양한 환경에 대한 자동화를 가능하게 합니다. 이를 통해 코드 변경 사항이 여러 아키텍처에 대해 자동으로 테스트되고 배포될 수 있습니다.

이러한 기능들은 도커를 사용하여 애플리케이션을 다양한 환경에 배포하는 과정을 간소화하고, 플랫폼 간의 호환성을 높이는 데 큰 도움을 줍니다.


#### 3.4. 도커의 컨테이너화(Containerization)

**컨테이너화**는 도커의 핵심 기능 중 하나로, 애플리케이션과 그 실행 환경을 패키지화하여 어디서든 일관되게 실행할 수 있도록 만들어 줍니다. <br/> 이는 개발, 테스트, 배포 환경의 차이를 극복하고, 애플리케이션을 빠르고 효율적으로 배포할 수 있는 방법을 제공합니다. 도커 컨테이너는 애플리케이션을 경량화된 프로세스로 분리된 환경에서 실행되도록 하여 자원의 효율성을 극대화합니다.

#### 컨테이너화의 주요 개념

1. **도커 이미지(Docker Image)**:
   도커 이미지는 애플리케이션 실행에 필요한 모든 것을 포함하는 읽기 전용 템플릿입니다. 애플리케이션 코드, 라이브러리, 시스템 도구, 설정 파일 등이 포함되며, 이미지를 기반으로 컨테이너가 생성됩니다. 도커 이미지는 레이어로 구성되어 있으며, 변경 사항이 있을 때마다 새 레이어를 추가하는 방식으로 저장됩니다. 이는 기존 레이어의 재사용을 가능하게 하여 효율적인 저장과 전송을 돕습니다.


> 1. 레이어(Layer) 구조 <br/>
도커 이미지는 여러 레이어로 구성되어 있으며, 각 레이어는 그 위에 쌓이는 방식으로 저장됩니다. 예를 들어, 첫 번째 레이어는 기본 OS 이미지일 수 있고, 그 위에 필요한 시스템 도구와 라이브러리가 추가되며, 마지막 레이어에는 애플리케이션 코드와 설정이 포함될 수 있습니다. 이 구조는 이미지의 변경 사항을 효율적으로 처리할 수 있게 해줍니다. 변경 사항이 생길 때마다 전체 이미지를 다시 만들 필요 없이, 새로 추가된 부분만 새로운 레이어로 추가하고 나머지 기존 레이어는 그대로 재사용할 수 있습니다.

> 2. 효율성 및 저장 공간 절약 <br/>
도커 이미지는 기존의 가상 머신과는 달리, 각 레이어를 재사용할 수 있기 때문에 이미지 간의 중복을 최소화합니다. 예를 들어, 여러 이미지가 동일한 기본 OS나 시스템 도구를 필요로 한다면, 그 부분은 한 번만 저장되고 여러 이미지에서 공유할 수 있습니다. 이로 인해 이미지의 저장 공간을 절약하고, 전송 시간도 크게 줄일 수 있습니다.

> 3. 불변성 <br/>
도커 이미지는 불변(read-only)입니다. 즉, 한 번 생성된 이미지는 수정되지 않습니다. 수정이 필요한 경우, 기존 이미지에 새로운 레이어를 쌓아 변경된 부분만 추가하게 됩니다. 이렇게 불변성을 유지함으로써 이미지를 안전하게 보관하고, 배포 과정에서도 오류나 충돌을 방지할 수 있습니다.

2. **도커 컨테이너(Docker Container)**:
   컨테이너는 도커 이미지를 기반으로 실행되는 가상화된 애플리케이션 인스턴스입니다. 각각의 컨테이너는 독립적인 파일 시스템을 가지고 있으며, 격리된 환경에서 애플리케이션을 실행합니다. 컨테이너는 가볍고 빠르게 실행되며, 여러 개의 컨테이너를 동시에 실행할 수 있습니다.

> 1. 독립적인 파일 시스템<br/>
각 도커 컨테이너는 호스트 시스템과 독립된 파일 시스템을 가지고 있으며, 도커 이미지에서 파생된 파일 시스템을 사용합니다. 컨테이너 내부에서 이루어진 변경 사항은 컨테이너 외부에는 영향을 미치지 않으며, 컨테이너가 삭제되면 그 안에서 이루어진 모든 변경 사항도 함께 삭제됩니다. 이 독립적인 파일 시스템은 컨테이너 간의 격리성을 강화하고, 여러 애플리케이션을 동시에 실행하더라도 서로 간섭하지 않도록 보장합니다.

> 2. 컨테이너의 경량화<br/>
컨테이너는 가상 머신에 비해 훨씬 경량화되어 있습니다. 가상 머신은 전체 운영 체제를 포함하지만, 컨테이너는 운영 체제 커널을 호스트와 공유하고, 필요한 최소한의 시스템 도구와 라이브러리만 포함합니다. 이로 인해 리소스 사용량이 줄어들고, 컨테이너를 시작하는 데 걸리는 시간이 짧아집니다. 컨테이너는 몇 초 내에 실행될 수 있으며, 매우 낮은 오버헤드로 수백 개의 컨테이너를 동시에 실행할 수 있습니다.

> 3. 컨테이너 간 네트워크 및 통신 <br/>
도커 컨테이너는 격리된 환경에서 실행되지만, 서로 간에 네트워크 통신을 할 수 있습니다. 기본적으로 각 컨테이너는 독립된 네트워크 네임스페이스를 가지고 있지만, 도커의 네트워크 설정을 통해 컨테이너 간의 통신을 허용하거나, 외부 네트워크와 통신할 수 있는 환경을 설정할 수 있습니다. 이를 통해 분산 시스템을 구성하거나, 여러 컨테이너 간에 데이터 교환을 쉽게 처리할 수 있습니다.

3. **컨테이너 격리**:
   도커 컨테이너는 서로 격리되어 실행되므로, 한 컨테이너에서 발생하는 문제나 변경 사항이 다른 컨테이너에 영향을 미치지 않습니다. 이 격리성은 리소스 충돌을 방지하고, 다양한 애플리케이션을 동시에 실행하는 데 유용합니다.

> 1. 파일 시스템 격리<br/>
각 컨테이너는 자신의 파일 시스템을 가지고 있으며, 다른 컨테이너나 호스트 시스템과는 격리되어 있습니다. 이는 컨테이너가 호스트의 파일 시스템에 영향을 주지 않고, 다른 컨테이너와도 격리된 상태로 안전하게 실행될 수 있게 합니다.

> 2. 프로세스 격리 <br/>
각 컨테이너는 고유한 프로세스 네임스페이스를 사용합니다. 즉, 컨테이너 내에서 실행되는 프로세스는 해당 컨테이너 내에서만 보이며, 다른 컨테이너나 호스트 시스템에서는 보이지 않습니다. 이를 통해 한 컨테이너의 프로세스가 다른 컨테이너나 호스트 시스템에 영향을 미치지 않도록 보장합니다.

> 3. 네트워크 격리 <br/>
기본적으로 각 컨테이너는 독립된 네트워크 환경에서 실행되며, 외부와의 네트워크 연결을 제어할 수 있습니다. 이를 통해 필요에 따라 외부 네트워크와 차단된 상태로 컨테이너를 실행할 수 있으며, 다른 컨테이너와의 네트워크 통신도 제어할 수 있습니다. 예를 들어, 특정 컨테이너 간에만 네트워크 연결을 허용하거나, 외부에서 특정 컨테이너에만 접근할 수 있도록 설정할 수 있습니다.

4. **컨테이너 이식성**:
   도커 이미지는 OS에 종속적이지 않기 때문에 다양한 환경에서 동일한 이미지를 사용할 수 있습니다. 개발 환경에서 만든 이미지를 그대로 프로덕션 환경에 배포하여 일관성을 유지할 수 있습니다. 이를 통해 애플리케이션 이식성을 높이고, 환경 차이에 따른 문제를 최소화할 수 있습니다.

> 1. 환경 간 일관성<br/>
도커 이미지는 운영 체제나 하드웨어에 종속적이지 않습니다. 이는 개발자가 로컬에서 사용한 도커 이미지를 그대로 프로덕션 환경이나 테스트 환경에서도 사용할 수 있음을 의미합니다. 즉, 개발 환경과 배포 환경 간의 차이로 인해 발생하는 "개발 환경에서는 잘 되는데 프로덕션에서는 안 된다"는 문제를 해결할 수 있습니다.

> 2. 클라우드 및 온프레미스 이식성<br/>
도커 이미지는 클라우드 환경과 온프레미스 환경 모두에서 사용할 수 있습니다. 클라우드 제공업체 간에도 도커 이미지를 쉽게 이동할 수 있기 때문에, 특정 클라우드 제공업체에 종속되지 않고, 원하는 환경에서 애플리케이션을 실행할 수 있습니다. 이로 인해 클라우드 마이그레이션이 쉬워지고, 벤더 락인(Vendor lock-in) 문제를 최소화할 수 있습니다.

> 3. 멀티 플랫폼 지원 <br/>
도커는 다양한 운영 체제와 플랫폼에서 실행될 수 있습니다. 도커 이미지는 리눅스뿐만 아니라 Windows 컨테이너도 지원하며, Apple Silicon과 같은 ARM 기반 아키텍처에서도 실행될 수 있습니다. 이는 애플리케이션을 다양한 플랫폼에서 쉽게 실행할 수 있게 해 주며, 하드웨어와 소프트웨어 간의 호환성 문제를 해결할 수 있습니다.
